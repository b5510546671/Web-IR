
<html>
<head>
   <title>introduction</title>
</head>
<body>

<center>
<table cols=1 width="95%" bgcolor="#ffcc99" >
<tr>
<td align=center width="95%"><b><font face="ms sans serif"><font color="#000099"><font size=-1>ram
(random access memory)&nbsp;</font></font></font></b></td>
</tr>
</table>
<p>
<table cols=1 width="95%" >
<tr>
<td width="95%">
<dd>
<font face="ms sans serif"><font size=-1>คือ<wbr>หน่วย<wbr>ความ<wbr>จำ<wbr>ที่<wbr>มี<wbr>การ<wbr>เข้า<wbr>ถึง<wbr>ได้
โดย<wbr>ไม่<wbr>ต้อง<wbr>ใส่<wbr>ลำ<wbr>ดับ (sequential access) ต้อง<wbr>การ<wbr>ข้อ<wbr>มูล ที่<wbr>ตำแหน่ง<wbr>ใด<wbr>ก็<wbr>ได้
โดย<wbr>ส่ง address (ตัว<wbr>เลข<wbr>ระบุ<wbr>ตำแหน่ง) ให้กับ ram memory chip ที่<wbr>ใช้<wbr>กัน<wbr>ในเครื่องพี<wbr>ซี<wbr>แบ่ง<wbr>ได้<wbr>เป็น
2 ประเภท<wbr>ใหญ่ๆ ได้<wbr>แก่<wbr><wbr></font></font></dd>

<dd>
<font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1.sram(static ram)</font></font></dd>

<dd>
<font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2.dram(dynamic ram)</font></font></dd>

<dd>
<font face="ms sans serif"><font size=-1></font></font></dd>

<dd>
<font face="ms sans serif"><font size=-1>คุณสมบัติ<wbr>ที่<wbr>แตก<wbr>ต่าง<wbr>กัน ระหว่าง
sram กับ dram คือ sram มี<wbr>ราคา<wbr>สูง<wbr>กว่า เนื่อง<wbr>จาก sram มี ความ<wbr>เร็ว<wbr>สูง<wbr>กว่า
dram</font></font></dd>

<dd>
<font face="ms sans serif"><font size=-1>การ<wbr>ใช้<wbr>งาน ram นั้น ต้อง<wbr>มี<wbr>ไฟ<wbr>เลี้ยง<wbr>ตลอด<wbr>เวลา
และ<wbr>นอก<wbr>จาก<wbr>ไฟ<wbr>เลี้ยง<wbr>แล้ว dram ยัง<wbr>ต้อง<wbr>การ การ refresh ข้อ<wbr>มูล<wbr>เป็น<wbr>ระยะๆ เสมือน<wbr>การ<wbr>เตือน<wbr>ความ<wbr>ทรง<wbr>จำ
ซึ่ง ผิดกับ sram ที่<wbr>ไม่<wbr>ต้อง<wbr>มี<wbr>การ refresh เนื่อง<wbr>จาก dram ซึ่ง<wbr>ทำ<wbr>มา<wbr>จาก mosใช้<wbr>หลัก<wbr>การ
ของ<wbr>ตัว<wbr>เก็บ<wbr>ประจุ มา<wbr>เก็บ<wbr>ข้อ<wbr>มูล เมื่อ<wbr>เวลา<wbr>ผ่าน<wbr>ไป ประจุ<wbr>จะ<wbr>ค่อยๆรั่ว<wbr>ออก ทำ<wbr>ให้<wbr>ต้อง<wbr>มี<wbr>การ
refresh ประจุ<wbr>ตลอด<wbr>เวลา<wbr>การ<wbr>ใช้<wbr>งาน ส่วน sram ซึ่ง<wbr>ทำ<wbr>มา<wbr>จาก flip-flop นั้น ไม่<wbr>จำ<wbr>เป็น<wbr>ต้อง<wbr>มี<wbr>การ
refresh แต่ sram จะ<wbr>กิน<wbr>ไฟ<wbr>มาก<wbr>กว่า dram อัน<wbr>เนื่อง<wbr>จาก<wbr>การ<wbr>ใช้ flip-flop นั่น<wbr>เอง<wbr><wbr></font></font></dd>
<font face="ms sans serif"><font size=-1></font></font>
<p><b><font face="ms sans serif"><font size=-1>ความ<wbr>เร็ว<wbr>ของ ram คิด<wbr>กัน<wbr>อย่าง<wbr>ไร<wbr><wbr></font></font></b>
<dd>
<font face="ms sans serif"><font size=-1>ที่<wbr>ตัว memorychip จะ<wbr>มี เลข<wbr>รหัส
เช่น hm411000-70 ตัว<wbr>เลข<wbr>หลัง (-) คือ ตัว<wbr>เลข<wbr>ที่<wbr>บอก ความ<wbr>เร็ว<wbr>ของ ram ตัว<wbr>เลข<wbr>นี้
เรียก<wbr>ว่า accesstime คือ เวลา<wbr>ที่<wbr>เสีย<wbr>ไป ใน<wbr>การ<wbr>ที่<wbr>จะ<wbr>เข้า<wbr>ถึง<wbr>ข้อ<wbr>มูล หรือ เวลา<wbr>ที่<wbr>แสดง<wbr>ว่า
ข้อ<wbr>มูล<wbr>จะ<wbr>ถูก ส่ง<wbr>ออก<wbr>ไป<wbr>ทาง data busได้<wbr>เร็ว<wbr>แค่<wbr>ไหน ยิ่ง access time น้อยๆ แสดง<wbr>ว่า
ram ตัว<wbr>นั้น เร็ว<wbr>มาก<wbr><wbr></font></font></dd>
<font face="ms sans serif"><font size=-1></font></font>

<p><b><font face="ms sans serif"><font size=-1>ตา<wbr>ราง<wbr>ค่า access time
บน chip</font></font></b>
<p>
<center><table border >
<tr bgcolor="#66ffff">
<td><font face="ms sans serif"><font size=-1>access time(ns)&nbsp;</font></font></td>

<td>
<center><font face="ms sans serif"><font size=-1>ตัว<wbr>เลข<wbr>ที่<wbr>พบ<wbr>บน memory chip</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>250&nbsp;</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>25</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>200</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>20</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>150</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>15&nbsp;</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>120</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>12</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>100</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>10</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>85&nbsp;</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>85</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>80&nbsp;</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>8,80</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>70</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>7,70</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>65</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>65</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>60</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>6,60</font></font></center>
</td>
</tr>

<tr>
<td>
<center><font face="ms sans serif"><font size=-1>53</font></font></center>
</td>

<td>
<center><font face="ms sans serif"><font size=-1>53</font></font></center>
</td>
</tr>
</table></center>

<p>
<dd>
<font face="ms sans serif"><font size=-1>ความ<wbr>เร็ว<wbr>ของ ram เรียก<wbr>ว่า cycle
time ซึ่ง<wbr>มี<wbr>หน่วย<wbr>เป็น ns โดย cycle time เท่ากับ read/write cycle time (เวลา<wbr>ที่<wbr>ใน<wbr>การ<wbr>ส่ง<wbr>สัญญาณ<wbr>ติด<wbr>ต่อ
ว่า<wbr>จะ<wbr>อ่าน<wbr><wbr>/เขียน ram) รวมกับ access time และ refresh time</font></font></dd>

<dd>
<font face="ms sans serif"><font size=-1>โดย<wbr>ทั่ว<wbr>ไป ram จะ<wbr>ต้อง<wbr>ทำ<wbr>การ<wbr>ตอบ<wbr>สนอง
cpu ได้<wbr>ใน<wbr>เวลา 2 clock cycle หรือ 2 คาบ หาก ram ตอบ<wbr>สนอง<wbr>ไม่<wbr>ทัน ram จะ<wbr>ส่ง<wbr>สัญญาณ
/wait บอก cpu ให้ คอย คือ การ<wbr>ที่ cpu เพิ่ม clock cycle ซึ่ง<wbr>ช่วง<wbr>เวลา<wbr>นี้<wbr>เรียก<wbr>ว่า
wait state</font></font></dd>
<font face="ms sans serif"><font size=-1></font></font>
<p><b><font face="ms sans serif"><font size=-1>วิธี<wbr>ที่<wbr>ใช้<wbr>ใน<wbr>การ<wbr>แก้<wbr>ไข
wait state</font></font></b>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp; <b>1. เทคนิค
interleave</b></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
เทคนิค<wbr>นี้<wbr>เป็น<wbr>การ<wbr>ลด<wbr>ปัญหา<wbr>เรื่อง refresh time เพราะ<wbr>ใน<wbr>การ<wbr>ทำ<wbr>งาน<wbr>ของ ram จะ<wbr>เห็น<wbr>ว่า<wbr>ใน
การ<wbr>ติด<wbr>ต่อกับ memory 1 address จะ<wbr>ใช้<wbr>เวลา 1 cycle time ใน<wbr>การ<wbr>ที่ cpu ติด<wbr>ต่อ
กับ memory ใน<wbr>แต่<wbr>ละ<wbr>ครั้ง จะ<wbr>ติด<wbr>ต่อ<wbr>เป็น block คือ หลาย address เรียง<wbr>ต่อ<wbr>กัน
จาก<wbr>ความ<wbr>จริง ข้อ<wbr>นี้ เทคนิค<wbr>การ interleave จึง<wbr>เกิด<wbr>ขึ้น โดย<wbr>หลัก<wbr>การ<wbr>ที่<wbr>จะ<wbr>ทำ<wbr>ให้
cycle time เหลื่อม<wbr>กัน<wbr>เกิด<wbr>จน cycle time ใหม่<wbr>ที่<wbr>แคบ<wbr>ลง<wbr><wbr></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
การ<wbr>สลับ bank ของ memory โดย bank บล็อก<wbr>หนึ่ง<wbr>จะ<wbr>มี memory address เป็น<wbr>เลข<wbr>คี่
อีก bank จะ<wbr>เป็น<wbr>เลข<wbr>คู่ เวลา cpu ติด<wbr>ต่อ<wbr>สลับ<wbr>ไป<wbr>สลับ<wbr>มา<wbr>ใน 2 bank เพราะ<wbr>ฉะนั้น<wbr>ต้อง<wbr>ใส่
memory ให้<wbr>เต็ม bank เป็น<wbr>จำนวน<wbr>คู่ เช่น 2 bank หรือ 4 bank ถ้า memory ขนาด<wbr>เท่า<wbr>กัน
คน<wbr>ที่<wbr>ใส่ memory ทั้ง<wbr>หมด<wbr>ไว้<wbr>ใน bank เดียว จะ<wbr>ทำ<wbr>งาน<wbr>ได้<wbr>ช้า<wbr>กว่า คน<wbr>ที่<wbr>แบ่ง memory
ใส่<wbr>เป็น 2 bank แต่ bank ก็<wbr>จะ เหลือ<wbr>น้อย<wbr>ด้วย<wbr><wbr></font></font><font face="ms sans serif"><font size=-1></font></font>
<p><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp; <b>2. วิธี<wbr>การ
page mode</b></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
วิธี<wbr>การ<wbr>นี้<wbr>จะ<wbr>ต้อง<wbr>ใช้ ram พิเศษ คือ paged ram โดย memory จะ<wbr>ถูก<wbr>มอง<wbr>ว่า แบ่ง
เป็น<wbr>กลุ่ม หรือ page หลาย page ใน<wbr>การ<wbr>ติด<wbr>ต่อกับ memory ที่ address อยู่<wbr>ใน
page เดียว<wbr>กัน ต่อๆ ไป โดย<wbr>ไม่<wbr>ต้อง<wbr>มี wait state แต่<wbr>ถ้า<wbr>มี<wbr>การ<wbr>ติด<wbr>ต่อกับ page
อื่น จะ<wbr>มี wait state เหมือนเดิม<wbr></font></font><font face="ms sans serif"><font size=-1></font></font>
<p><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp; <b>3. cache
memory memory</b></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ส่วน<wbr>นี้<wbr>จะ<wbr>ถูก<wbr>รวมกับ cpu ซึ่ง<wbr>ก็<wbr>คือ internal cache แต่<wbr>ถ้า<wbr>เอา<wbr>มา<wbr>ติด<wbr>บนเมน<wbr>บอร์<wbr>ด
จะ<wbr>เรียก<wbr>ว่า external cache ก็<wbr>คือ ram นั่น<wbr>เอง แต่<wbr>ความ<wbr>เร็ว<wbr>จะ<wbr>สูง<wbr>มาก ทำ<wbr>ให้<wbr>ไม่<wbr>มี<wbr>ภาวะ
wait state วิธี<wbr>การ<wbr>ก็<wbr>คือ พยายาม<wbr>ให้ cpu ติด<wbr>ต่อกับ cache ซึ่ง<wbr>เป็น sram ความ<wbr>เร็ว<wbr>สูง<wbr>ก่อน
เพราะ ไม่<wbr>มี<wbr>ภาวะ waitstate โดย<wbr>จะ<wbr>มี<wbr>วง<wbr>จร cache controller ซึ่ง<wbr>เป็น ตัว<wbr>จัด<wbr>การ
cache โดย<wbr>มัน<wbr>จะ<wbr>ตัด บล็อก<wbr>ข้อ<wbr>มูล<wbr>จาก main memory ประมาณ<wbr>บล็อก<wbr>ละ 2-4 kb มา<wbr>ใส่<wbr>ไว้<wbr>ใน
cache พอ cpu ติด<wbr>ต่อ memory ก็<wbr>จะ<wbr>มา<wbr>ดู<wbr>ใน cache ก่อน<wbr>ว่า<wbr>มี<wbr>ข้อ<wbr>มูล<wbr>ที่<wbr>ต้อง<wbr>การ<wbr>หรือ<wbr>ไม่
ถ้า<wbr>ไม่<wbr>มี<wbr>ก็<wbr>จะ<wbr>ไป<wbr>เอา<wbr>จาก main memory ความ<wbr>สำคัญ<wbr>ของ cache คือ การ<wbr>ตัด<wbr>บล็อก<wbr>มา<wbr>ให้<wbr>ถูก<wbr>ตาม<wbr>ความ<wbr>ต้อง<wbr>การ<wbr>ของ
cpu โดย cache controller จะ<wbr>ใช้<wbr>วิธี<wbr>การ random แต่ random อย่าง<wbr>มี<wbr>หลัก<wbr>การ
คือ cpu มัก<wbr>ต้อง<wbr>การ ข้อ<wbr>มูล<wbr>ที่<wbr>ต่อ<wbr>เนื่อง<wbr>กัน เพราะ<wbr>ฉะนั้น cache จะ<wbr>ตัด<wbr>ข้อ<wbr>มูล<wbr>บล็อก<wbr>ถัด<wbr>ไป<wbr>มา<wbr>เก็บ<wbr>ไว้
การ random แบบ<wbr>นี้<wbr>ให้<wbr>ความ<wbr>แม่น<wbr>ยำ<wbr>ถึง 80% ที<wbr>เดียว คือ ไม่<wbr>มี<wbr>ภาวะ wait state
เป็น<wbr>เวลา 80% ของ<wbr>เวลา<wbr>ที่<wbr>ใช้ ทำ<wbr>งาน<wbr>ทั้ง<wbr>หมด<wbr><wbr></font></font><font face="ms sans serif"><font size=-1></font></font>
<p><b><font face="ms sans serif"><font size=-1>การ check parity</font></font></b>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
การ<wbr>เช็ค parity เป็น<wbr>การ เพิ่ม<wbr>บิตพิเศษ<wbr>เข้า<wbr>ไป<wbr>อีก 1 บิต ให้กับทุกๆ 8 บิต ของ<wbr>ข้อ<wbr>มูล
จน<wbr>กลาย<wbr>เป็น 9 บิต บิตที่<wbr>เพิ่ม<wbr>ขึ้น<wbr>ไม่<wbr>ใช่<wbr>ข้อ<wbr>มูล แต่<wbr>ใส่<wbr>เพื่อ<wbr>ตรวจ<wbr>สอบ<wbr>ว่า ข้อ<wbr>มูล<wbr>มี<wbr>ความ<wbr>ผิด<wbr>พลาด<wbr>หรือ<wbr>ไม่
โดย<wbr>ใช้<wbr>หลัก<wbr>การ<wbr>นับ<wbr>ขำนวน<wbr>บิตข้อ<wbr>มูล<wbr>ที่<wbr>มี<wbr>ค่า<wbr>เป็น 1 ใน<wbr>ทุกๆ 8 บิต การเข็ค parity
นี้<wbr>แบ่ง<wbr>ได้ 2 วิธี คือ odd parity (parity คี่) และ even parity (parityคู่)</font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
สำหรับ<wbr>วิธี odd parity จะ<wbr>ทำ<wbr>การ<wbr>นับ<wbr>จำนวน<wbr>บิตที่<wbr>เป็น 1 ใน 8 บิตว่า<wbr>มี<wbr>จำนวน<wbr>เป็น<wbr>คู่
หรือ<wbr>เป็น<wbr>คี่ โดย<wbr>มี ic 74ls280 ทำ<wbr>หน้า<wbr>ที่<wbr>เป็น<wbr>ตัว<wbr>สร้าง parity และ เป็น<wbr>ตัว<wbr>ตรวจ<wbr>สอบ
ถ้า 74ls280 นับ<wbr>จำนวน 1 ใน 8 บิตได้ เป็น<wbr>จำนวน<wbr>คู่<wbr>ที่ parity bit จะ<wbr>ถูกเซ็ตให้<wbr>เป็น
1 เพื่อ<wbr>ให้<wbr>จำนวน<wbr>ของ 1 ใน 9 บิต (รวม parity bit ด้วย) เป็น<wbr>จำนวน<wbr>คี่ แต่<wbr>ถ้า<wbr>นับ<wbr>จำนวน<wbr>ของ
1 ใน 8 บิต ได้<wbr>เป็น<wbr>เลข<wbr>คี่ parity bit จะ<wbr>ถูกเซ็ตให้<wbr>เป็น 0 เพื่อ<wbr>ให้<wbr>จำนวน<wbr>ของ
1ใน 9 บิต รวม<wbr>เป็น<wbr>เลข<wbr>คี่ ถ้า<wbr>วิธ ี<wbr>even parity ก็<wbr>จะ<wbr>ทำ<wbr>ใน ทา<wbr>งก<wbr>ลับ<wbr>กัน คือ<wbr>พยายามเซ็<wbr>ต
parity ให้<wbr>จำนวน<wbr>ของ 1 ใน 9 บิตเป็น<wbr>จำนวน<wbr>คู่<wbr><wbr></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
parity bit จะ<wbr>ถูก<wbr>สร้าง<wbr>ตอน เขียน<wbr>ข้อ<wbr>มูล<wbr>ลง<wbr>ใน ram และ<wbr>จะ<wbr>ถูก<wbr>ตรวจ<wbr>สอบ เมื่อ<wbr>มี<wbr>การ
อ่าน<wbr>ข้อ<wbr>มูล<wbr>จาก ram เช่น ถ้า<wbr>ข้อ<wbr>มูล<wbr>เป็น 11001010 ด้วย<wbr>วิธี odd parity จะ เซ็<wbr>ต
parity bit เป็น 1 แต่<wbr>ถ้า<wbr>ตอน<wbr>อ่าน<wbr>ข้อ<wbr>มูล<wbr>เกิด<wbr>การ<wbr>เปลี่ยน<wbr>แปลง<wbr>เป็น 10001010 โดย
odd parity ยัง<wbr>คง<wbr>เป็น 1 ก็<wbr>จะ<wbr>แสดง ว่า<wbr>มี<wbr>การ<wbr>ผิด<wbr>พลาด<wbr>เกิด<wbr>ขึ้น ic 74ls280 จะ<wbr>ทำ<wbr>การ<wbr>สร้าง<wbr>สัญญาณ<wbr>ไป<wbr>บอก<wbr>ให้
cpu เกิด<wbr>การ halt และ<wbr>แสดง<wbr>ข้อ<wbr>ความ<wbr>ราย<wbr>งาน<wbr>ทางหน้า<wbr>จอ<wbr>ใน<wbr>แบบ<wbr>ต่างๆ เช่น parity error
system halt</font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ข้อ<wbr>เสีย<wbr>ของ<wbr>การ<wbr>ใช้ parity bit คือ เสีย<wbr>เวลา และ<wbr>ไม่<wbr>ได้<wbr>ประ<wbr>โยชน์<wbr>เท่า<wbr>ไร<wbr>นัก เพราะ<wbr>ไม่
สามารถ<wbr>บอก<wbr>ได้<wbr>ว่า<wbr>ผิด<wbr>ที่<wbr>ตำแหน่ง<wbr>ไหน และ<wbr>แก้<wbr>ไข<wbr>ข้อ<wbr>ผิด<wbr>พลาด<wbr>ไม่<wbr>ได้ บอก<wbr>ได้<wbr>แค่<wbr>ว่า<wbr>มี<wbr>ความ<wbr>ผิด<wbr>พลาด
เกิด<wbr>ขึ้น<wbr>เท่า<wbr>นั้น ยิ่ง<wbr>กว่า<wbr>นั้น ถ้า<wbr>สมมติ ข้อ<wbr>มูล<wbr>เกิด<wbr>ผิด<wbr>พลาด<wbr>ที<wbr>เดียว 2 บิต เช่น
10001001 เปลี่ยน<wbr>เป็น 10101011 เรา<wbr>ก็<wbr>ไม่<wbr>สามารถ<wbr>เช็ค<wbr>ข้อ<wbr>ผิด<wbr>พลาด<wbr>โดย<wbr>ใช้<wbr>วิธี parity
ได้<wbr><wbr></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
เมื่อ<wbr>รู้<wbr>การ<wbr>ทำ<wbr>งาน<wbr>ของ ram แล้ว เรา<wbr>ก็<wbr>จะ<wbr>มา<wbr>ดู ประเภท<wbr>ของ ram ที่<wbr>มี<wbr>ใช้<wbr>กัน<wbr>อยู่<wbr><wbr></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1. dip (dual in-line package) เป็น<wbr>แบบ<wbr>พื้น<wbr>ฐาน<wbr>ที่<wbr>ใช้<wbr>กัน เพราะ dip คือ ram
ที่<wbr>อยู่<wbr>ใน<wbr>รูป<wbr>แบบ<wbr>ของ ic (integrate circuit ) หรือ memory chip การ<wbr>ใช้<wbr>งาน หรือ<wbr>ติด<wbr>ตั้ง
ram ชนิด<wbr>นี้<wbr>ทำ<wbr>ได้<wbr>โดย<wbr>การ<wbr>ติด<wbr>ลง<wbr>บน ซ็อคเก็ตของ dip เท่า<wbr>ที่เมน<wbr>บอร์ดเตรียม<wbr>ไว้<wbr>ให้
นั่น<wbr>หมาย<wbr>ความ<wbr>ว่า ยิ่ง<wbr>ความ<wbr>ต้อง<wbr>การ<wbr>ติด dip มากๆ เมน<wbr>บอร์ดก็<wbr>ต้อง<wbr>มีซ็อคเก็ตไว้<wbr>ให้<wbr>มาก<wbr>ๆ
ผล<wbr>ก็<wbr>คือ ใช้<wbr>พื้น<wbr>ที่<wbr>เปลือง และ<wbr>ทำ<wbr>ให้เมน<wbr>บอร์ดใหญ่<wbr>มาก ใน<wbr>การ<wbr>ติด dip ยัง<wbr>ต้อง<wbr>ระ<wbr>มัด<wbr>ระวัง<wbr>ด้วย
เพราะ pin บอบ<wbr>บาง งอ<wbr>ง่าย หัก<wbr>ง่าย ทั้ง<wbr>ยัง เสีย<wbr>เวลา<wbr>ใน<wbr>การ<wbr>ติด<wbr><wbr></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2. sipp (single in-line pin package) จะ<wbr>ลด<wbr>ความ<wbr>ยุ่ง<wbr>ยาก<wbr>ของ<wbr>การ<wbr>ติด<wbr>ตั้ง ram แบบ
dip ลง โดย<wbr>ติด<wbr>ลง<wbr>บน<wbr>แผ่น pcb (printed circuit board) ซะก่อน sipp เป็น<wbr>แผ่น
pcb ที่<wbr>มี pin ซึ่ง<wbr>เหมือน<wbr>ขา<wbr>ของ ic แต่ pin ของ sipp จะ<wbr>มี<wbr>เพียง<wbr>แถว<wbr>เดียว<wbr>เรียง<wbr>ไป<wbr>ตาม<wbr>แนว<wbr>ยาว<wbr>ของ<wbr>แผ่น
pcb การ<wbr>ติด<wbr>ตั้ง sipp ที่<wbr>มี<wbr>ลักษณะ<wbr>เป็น<wbr>รู<wbr>กลม<wbr>เรียง<wbr>หนึ่ง<wbr>เป็น<wbr>แถว<wbr>ยาว<wbr>มี<wbr>จำนวน<wbr>รู<wbr>เท่ากั<wbr>บ
pin ของ sipp พอ<wbr>ดี ประ<wbr>หยัด<wbr>เนื้อ<wbr>ที่<wbr>บนเมน<wbr>บอร์ด และ<wbr>ติด<wbr>ตั้ง<wbr>ง่า<wbr>ยก<wbr>ว่า dip มาก<wbr><wbr></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3. simm (single in-line memory module) รูป<wbr>ร่าง<wbr>หน้า<wbr>ตา จะ<wbr>คล้ายกับ sipp แต่<wbr>ต่าง
ส่วน<wbr>ที่<wbr>จะ<wbr>ต่อกับ ซ็อคเก็<wbr>ตบนเมน<wbr>บอร์ด จาก pin เป็น<wbr>แบบ edge connector คือ<wbr>เป็น
ลาย<wbr>วง<wbr>จร<wbr>เรียง กัน<wbr>เป็น<wbr>ซี่<wbr>ตาม<wbr>ขอบ<wbr>ของ pcb ใน<wbr>แนว<wbr>ยาว ลักษณะ<wbr>เหมือนกับ ที่<wbr>เห็น<wbr>ตาม<wbr>การ์ด<wbr>ต่าง<wbr>ๆ
แต่<wbr>ใน<wbr>การ<wbr>ติด<wbr>ตั้ง simm จะ<wbr>ไม่<wbr>ใช้<wbr>การ<wbr>เสียบ<wbr>ลง<wbr>ไป<wbr>ตรงๆ เหมือน<wbr>การ์ด<wbr>ทั่ว<wbr>ไป แต่<wbr>จะ<wbr>เสียบ<wbr>ลง<wbr>แบบ<wbr>เอียงๆแล้ว<wbr>ดัน<wbr><wbr>simm
ไป<wbr>ด้าน<wbr>ข้าง<wbr>เพื่อ<wbr>ให้ กล<wbr>ไก<wbr>บนซ็อคเก็ตทำ<wbr>การล็อก simm เอา<wbr>ไว้ การ<wbr>ใช้ edge connector
ใน<wbr><wbr>simm ก็<wbr>เพื่อ<wbr>ตัด<wbr>ปัญหา<wbr>เรื่อง<wbr>หน้า<wbr>สัมผัส<wbr>ของ pin กับซ็อคเก็ต<wbr></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
simm ที่<wbr>ถูก<wbr>ผลิต<wbr>ออก<wbr>มา<wbr>จะ<wbr>แบ่ง<wbr>ได้<wbr>เป็น<wbr>ชนิด<wbr>ต่างๆ ตาม<wbr>ความ<wbr>กว้าง<wbr>ของ<wbr>ข้อ<wbr>มูล<wbr>ของ simm
แต่<wbr>ละโมดูล คือ ชนิด 8 บิต<wbr>, 16 บิต<wbr>, 32 บิต การ<wbr>จัด<wbr>วาง<wbr>ลำ<wbr>ดับ<wbr>ของ edge connector
จะ<wbr>มี<wbr>มาตร<wbr>ฐาน กลาง<wbr>ที่<wbr>ใช้<wbr>กัน<wbr>อยู่<wbr><wbr></font></font>
<br><font face="ms sans serif"><font size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
4. dimm (dual in-line memory module) เป็น ram ชนิด<wbr>ใหม่ และ<wbr>ถูก<wbr>กำหนด ให้<wbr>เป็น<wbr>มาตร<wbr>ฐาน<wbr>กลาง<wbr>โดย
jedec (joint electron device engineering council) ลักษณะ<wbr>โดย ทั่ว<wbr>ไป จะ<wbr>คล้าย
simm แต่<wbr>จะ<wbr>มี 168 pin (ข้าง<wbr>ละ 84 pin )</font></font>
<p>
<hr width="100%">
<i><font face="ms sans serif"><font size=-2>รวบรวมจาก บทเรียน online วิชา 204323 ไมโครโปรเซสเซอร์และการออกแบบไมโครคอมพิวเตอร์ รศ.ยืน ภู่วรวรรณ </font></font></i>
</td></tr></table>
</center>
</body>
</html>
